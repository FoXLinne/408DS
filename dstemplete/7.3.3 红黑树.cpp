// 平衡二叉树 AVL 插入/删除很容易破坏平衡特性，对时间开销要求大
// 红黑树 RBT 插入/删除不会破坏“红黑”特性，即便需要调整，都可以在常数级时间内完成

// 平衡二叉树适用于以查为主，很少插入/删除的场景
// 红黑树适用于实用性更强的场景

// 红黑树是二叉排序树 （左 <= 根 <= 右）
    // 1. 每个节点或是红色或是黑色
    // 2. 根节点是黑色
    // 3. 叶节点（外部节点、NULL节点、失败节点）均是黑色
    // 4. 不存在两个相邻的红色节点（红色节点的父节点和孩子节点均是黑色）
    // 5. 对每个节点，从该节点到每个叶节点的路径上，均包含相同数量的黑色节点

// 定义红黑树
struct RBNode {
    int key;
    RBNode* parent;
    RBNode* lChild;
    RBNode* rChild;
    int color; // 0表示黑色，1表示红色
};

// 节点的黑高 bh 从某节点出发（不含该节点）到达任何一个叶节点的路径上，黑色节点的数量

// 红黑树的性质
    // 1. 从根节点到叶结点的最长路径不大于最短路径的 2 倍（左子树与右子树高度之差不超过 2 倍）
    // 2. 红黑树的高度 h <= 2 * log(n + 1)
    // 3. 红黑树的查找时间复杂度 O(log n)

// 红黑树的查找
// 从根节点出发，左小右大，直到找到目标节点，如果查找到一个空叶节点，则返回 NULL
// 查找的时间复杂度 O(log n)

// 红黑树的插入
    // 新节点是根，则为黑色
    // 新节点是红色
        // 1. 如果父节点是黑色，则直接插入（依然满足红黑树定义）
        // 2. 如果父节点是红色，则需要调整（不满足红黑树定义时）
            // 1. 如果叔叔节点是红色
                // 叔父爷染色，爷爷变为新节点
            // 2. 如果叔叔节点是黑色（旋转 + 染色）
                // 1. LL型：右旋转，父换爷，染色
                // 2. RR型：左旋转，父换爷，染色
                // 3. LR型：先左旋转，再右旋转，儿换爷，染色
                // 4. RL型：先右旋转，再左旋转，儿换爷，染色
