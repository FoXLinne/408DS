#include <bits/stdc++.h>
using namespace std;
// 大根堆
// 堆顶元素（二叉树的根）大于左右子树的元素

void swap(int &a, int &b) noexcept {
    // 交换两个元素的值
    int temp = a;
    a = b;
    b = temp;
}

void maxHeapify(int arr[], int k, int len) {
    // 将以 k 为根的子树调整为大根堆
    arr[0] = arr[k];
    // 数组的第 0 个位置用来临时存放调整的元素
    for (int i = 2 * k; i <= len; i *= 2) {
        // i 是当前节点的左子节点
        if (i <= len && arr[i] < arr[i + 1]) {
            i++;
            // 如果右子节点存在且大于左子节点，则将 i 指向右子节点
        }
        if (arr[0] >= arr[i]) {
            break;
        }   // 如果当前节点大于等于子节点，则不需要调整
        arr[k] = arr[i];
        k = i;
        // 否则将当前节点的值赋给子节点
        // 修改 k 的值为 i，继续向下调整
    }
    arr[k] = arr[0];
    // 全部调整结束后，将临时存放的值赋给当前节点
}

// 建立大根堆
void buildMaxHeap(int arr[], int len) {
    // 将普通数组转换为大根堆 对所有非叶子节点进行调整 (前 n/2 个节点为非叶子节点)
    for (int i = len / 2; i >= 0; i--) {
        maxHeapify(arr, i, len);
    }
}

// 堆排序
    // 每一趟在待排序元素中选择关键字最大的元素 (堆顶元素) 加入有序子序列
    // 将堆顶元素与 (待排序的) 有序子序列的最后一个元素交换6
    // 堆的结构发生改变，需要再次调整为大根堆 (传入的 k 为堆顶元素的下标，长度为 len-1)
    // 只剩下一个元素时，堆排序结束
    // 得到的序列是从小到大的

void heapSort(int arr[], int len) {
    buildMaxHeap(arr, len);
    // 建立大根堆
    for (int i = len; i > 0; i--) {
        swap(arr[1], arr[i]);
        // 将堆顶元素与最后一个元素交换
        maxHeapify(arr, 1, i - 1);
        // 调整为大根堆
    }
}

// 排序过程的算法效率分析
    // 建立大根堆的时间复杂度为 O(n)
    // 每次调整的时间复杂度为 O(logn)
    // 总体时间复杂度为 O(nlogn)
    // 空间复杂度为 O(1)，只需要一个临时变量存放元素
    // 适合大规模数据的排序

// 堆排序是不稳定的排序算法

// 在堆中插入新的元素 (以小根堆为例)
    // 先将元素插入表尾
    // 对于小根堆，如果新插入的元素小于父节点，则交换
    // 新节点不断向上调整，直到不小于父节点

// 在堆中删除元素
    // 删除元素，用最后一个元素替换
    // 将该元素向下调整，将结构调整为小根堆